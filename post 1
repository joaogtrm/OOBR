---
title: "Análise_de_consistência_e_tratamento_de_dados-post"
author: "Joao_Gabriel"
date: "2023-08-23"
output: html_document
---

As etapa de "análise de consistência" e "tratamento" de dados é, basicamente, uma etapa de padronização. É uma das mais importantes para qualquer trabalho envolvendo dados, pois é onde você irá buscar por erros de digitação, classificação de variáveis, entre outros casos, que, se não revisados, irão acarrtar em problemas futuros em qualquer projeto. O texto usará a base de dados disponibilizado pelo Observatório Obstétrico Brasileiro localizado em link

carregamento dos dados

Temos um post inteiro sobre importação de dados, encontrado no link "https://daslab-ufes.github.io/importando-dados/", então, iremos dar seguimento para a importação de fato. Quando baixarmos os dados, iremos obter um arquivo em formato .rds, então, iremos usara função readRDS() , encontrada no Rbase, ou seja, não precisando carregar uma biblioteca para usar, podendo ser usada de forma direta. Também usaremos a função head() para observarmos as 6 primeiras observações do data.frame que será criado, junto a função **kable** do pacote knitr, para uma melhor vizualização (recomendação: experimente usar a função sem, e com o "kable()" para entender o porque dessa função nos ajudar, neste caso).

(APAGAR!!!!!!!!!!

{r}
dados <- "https://raw.githubusercontent.com/observatorioobstetrico/dados_livro_cd_saude/main/base_um/basesuja_covid19.rds"

dados <- readRDS(url(dados, "rb"))

)

{r}
#dados <- readRDS("pasta_com_os_dados/arquivo_com_os_dados.rds")
knitr::kable(head(dados))


tratamento da base de dados

Nome das variáveis

Primeiramente, iremos verificar como os nomes das variaveis da nossa base de dados estão dispostas.

{r}
names(dados)

Uma boa prática para padronizar os nomes das variáveis é coloca-las todas em minúsculo, retirar acentos, e substituir espaços por "_" , pois esses são fatores que o R pode não entender da forma que a linguagem deveria. Um ótimo pacote para manipular nome de variáveis de uma base é a biblioteca janitor. Ela contém a função clean_names() que faz exatamente o que a gente está buscando.

*obs: neste exemplo, a única diferença visível foi que os nomes estão todos em minúscolos, porque eles já estavam sem acento e espaço, mas é importante ter em mente que esta não é a única função do clean_names()

{r message=FALSE, warning=FALSE}
#install.packages("janitor")
library(janitor)
dados <- janitor::clean_names(dados)
names(dados)

variaveis duplicadas ou vazias

É comum encontrarmos algumas observações duplicadas em nossa base, então sempre é interessante rodar o código get_dupes() para verificar a presença destas.

{r}
janitor::get_dupes(dados)


Esse código irá verificar se existe alguma observação repetida, ou seja, se tem uma variável com os exatos mesmos valores de outra. A primeira linha que nos é retornada nos diz que, como eu não especifiquei quais variaveis vou considerar para verificar, o código usará todas as disponíveis. A segunda linha nos diz que não há nenhuma observação duplicada. Se o caso fosse de existir dados duplicados, poderiamos resolver o problema usando a função distinct do pacote dplyr, que veremos a seguir.

identificar problemas nas variáveis

Comentado anteriormente, um dos pacotes mais poderosos para a manipulação de dados é o pacote dplyr, que usaremos para realizar as devidas transformações necessárias.

Quando nós lemos uma base de dados no R, é possível que algumas das nossas variáveis estejam classificadas de forma errada. Imagine que tenhamos uma variavel que represente um número, porém, o R entende que represente, na realidade, uma letra. Isso ocasionaria em problemas na nossa análise, portanto, é necessário entendermos como conferir esses casos.

Alguns dos tipos principais de dados são:

numeric: Esse tipo de dado representa tanto números inteiros quanto números de ponto flutuante. É usado para armazenar valores numéricos. Por exemplo: 3.14, -42, 100.

factor: Especificamente para armazenar números inteiros sem casas decimais. Por exemplo: 1, -10, 500.

string: Usado para armazenar texto ou sequências de caracteres. As sequências de caracteres são colocadas entre aspas simples ou duplas. Por exemplo: "Olá, mundo!", 'Programação em R'.

logic: Esse tipo representa valores booleanos, que podem ser TRUE (verdadeiro) ou FALSE (falso), indicando condições binárias. Por exemplo: TRUE, FALSE.

Date: Usado para armazenar datas. O R possui uma classe integrada chamada Date para lidar com datas. Por exemplo: as.Date("2023-08-24")

usaremos a função glimpse() para verificarmos a classe de cada uma das variáveis do nosso data.frame.

{r message=FALSE, warning=FALSE}
#installando e carregando o pacote
#install.packages("dplyr")
library(dplyr)

{r}
dplyr::glimpse(dados)

Percebemos que as variaveis de datas estão calssificadas como "characters", então, vamos arrumar usando a função as.Date() com a seguinte sintaxe:

{r}
#as.Date(base_de_dados$variável, format = "%d/%m/%Y")

repare que o "format" está para o formato de datas que usamos no Brasil, ou seja, "dia/mês/ano". agora, aplicaremos a formula para os casos necessários.

{r}
dados$dt_notific  <- as.Date(dados$dt_notific, format = "%d/%m/%Y")
dados$dt_sin_pri  <- as.Date(dados$dt_sin_pri, format = "%d/%m/%Y")
dados$dt_nasc  <- as.Date(dados$dt_nasc, format = "%d/%m/%Y")
dados$dt_interna  <- as.Date(dados$dt_interna, format = "%d/%m/%Y")
dados$dt_entuti  <- as.Date(dados$dt_entuti, format = "%d/%m/%Y")
dados$dt_saiduti  <- as.Date(dados$dt_saiduti, format = "%d/%m/%Y")

A função as.Date informa para o R que a variável indicada é de data. O argumento format indica o formato que está a data, nesse caso, "dia/mês/ano". Aqui é possível verificar todos os formatos de datas da função. Vamos ver como ficou:

{r}
glimpse(dados)

Agora, as variáveis que representam datas estão sendo consideradas corretamente pelo R.
